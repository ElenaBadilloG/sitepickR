---
title: "sitePickR: Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sitepickR-demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.width=8, fig.height=5) 
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Getting Started: Sampling AY 2017-18 California schools and districts

__Elena Badillo-Goicoechea, Robert Olsen, and Elizabeth A. Stuart__

2022-09-16

## Introduction

sitepickR is designed to select a representative sample of sites for a prospective impact evaluation, such as a randomized controlled trial (RCT). 

Like [generalizeR](https://nustat.github.io/generalizeR/), this package is designed for selecting schools but can be used to select any type of site defined by geography or administrative responsibility (e.g., county, job training center, health clinic). Unlike generalizeR, sitepicker is designed to select sites in two stages —first "units" that contain multiple sites located nearby and/or under the same administration and then "subunits" containing individual sites. Two-stage sampling may be necessary when the cost of the study depends on the number of units (e.g., school districts), and a one-stage sample of sub-units (e.g., schools) would likely contain more units than the study can afford.

The main function in this package, [selectMatch()](https://sitepickr.github.io/sitepickR-website/reference/selectMatch.html) lets the user carry out a two-level sample selection where the possibility of an initially selected unit not wanting to participate is anticipated. The procedure aims to reduce the bias (and/or loss of generalizability to the target population) this could introduce.

In selecting units and sub-units, sitepickR uses the cube method (e.g., Deville & Tillé, 2004; Tillé 2011). The cube method is a probability sampling method that is designed to satisfy criteria for balance between the sample and the population. Recent research has shown that this method performs well in simulations for studies of educational programs (Fay & Olsen, under review). To implement the cube method, sitepickerR uses the [sampling](https://cran.r-project.org/web/packages/sampling/index.html) R package. Users have the option to select units with equal probabilities or with probabilities proportional to their "size" measured in terms of the number of sub-units nested within units.


In addition, sitepickR uses statistical matching to select possible replacement units. In education RCTs, the share of selected districts that agrees to participate tends to be low. To address this challenge, sitepickR selects and ranks up to K replacement districts for each districts selected using the cube method. Replacement districts are selected using statistical matching based on propensity score methods. To implement statistical matching, sitepickR uses the [MatchIt](https://cran.r-project.org/web/packages/MatchIt/vignettes/MatchIt.html) R package.


sitepickR's core sampling + matching procedure, implemented with the selectMatch() function, consists of four main steps:

1.  __Study sample design__, where we:
    - Identify a target population with a unit : sub-unit nested structure (e.g. [district A : schools in district A])
    - Set key parameter values (e.g. initial sample size, desired number of matches per unit)
    - Specify a set of observable covariates of interest at the unit level
    - Specify a set of sub-unit level observable covariates of interest

2. Select a random __sample__ of units from the target population.

3. Obtain a list of __best K matches__ for each initially selected unit, where match no. 1 is closest to a given original unit and match no. K is furthest, in terms of the covariates of interest and key parameter values. 

These K matches will be the potential replacement units for each initially selected unit, in case their corresponding original unit is unable to participate in the study, and they are taken  (with or without repetition, which you can set with the [repFlag](https://sitepickr.github.io/sitepickR-website/reference/selectMatch.html) argument) from the pool of units that _did not_ get selected in the initial random sampling procedure.

4. Assess __balance__ and match quality in terms of the covariates of interest:
    - Balance between initially selected ('original') units and the target population.
    - Balance between original units and each group of matches (1 to K, from closest to further).
    - Balance between sub-units associated to each unit replacement group and the original sub-units in the population, in terms of available covariates of interest, both at the unit and sub-unit level. 

This vignette will guide the reader, step-by-step, on sitepickR's basic functionalities, with data from the [Common Core of Data (CCD)](https://sitepickr.github.io/sitepickR-website/reference/rwCCD.html) for California schools (2017-18), using a pre-processed dataset that comes with the package installation. Further technical details on each of the package's main functions and on the sample dataset is included in the documentation.

## Package and data set up

First, if needed, install the sitepickR package with the help of devtools:

```{r}
if(!require(devtools)){
    install.packages("devtools")
}

if(!require(sitepickR)){
    devtools::install_github("ElenaBadilloG/sitepickR")
    }
```

Now load the package by calling its library:

```{r}
library(sitepickR)
```

Now let's load the sample CCD-California 2017-18 dataset that comes installed with the package:


```{r, results='asis'}
rawCCD <- sitepickR::rawCCD
knitr::kable(head(rawCCD), format = "html")
```

Process the sample aggregate dataset in order for it to be in the exact format expected by selectMatch by using sitepckr [makeDF()](https://sitepickr.github.io/sitepickR-website/reference/makeDF.html) function. This will re-define some key variables and create a new variable, 'unitSize', that will be used in the step of the selectMatch procedure where units are initially sampled. Specifically, cube sampling allows us to (optionally) select units in a way that is not biased by its number of sub-units:

```{r, results='asis'}
dfCCD <- makeDF(rawCCD,
                 unitID="LEAID", subunitID="NCESSCH")
knitr::kable(dfCCD[1:10,(ncol(dfCCD)-5-1):ncol(dfCCD)], format = "html")
```

## Study sample design

### Define key input values

Since there is some underlying random sampling in selectMatch, we can set a seed for replication purposes (optional):
```{r}
seed = 1122 
```
 
Set distance tolerance for restricted covariates:
```{r}
calip = 0.2 # maximum standard deviations of covariate distance around target population
```

#### Set output sample sizes
Set size for: initial unit sample (Nu) , number of matches per unit (K), and number of sub-units selected for each potential unit:

```{r}
Nu <- 100 # district sample size
K <- 10 # number of matches per district
Ns <- 5 # number of schools per potential district
```

### Specify covariates of interest
Now, specify district level covariates on which you'll want to match selected districts (units) with their replacement candidates on the non-selected sample:

```{r}
uSampVarsCCD <- c("w.pct.frlunch", "w.pct.black", "w.pct.hisp", "w.pct.female") 
```
Similarly, specify school level covariates on which you'll want to match districts. In our running CCD example, these covariates are just school (sub-unit) level aggregates of the same district level underlying variable. However, they could be any other sub-unit level variables available in your own dataset:

```{r}
suSampVarsCCD <- c("sch.pct.frlunch", "sch.pct.black", "sch.pct.hisp", "sch.pct.female")
```
You can (optionally) specify covariates on which to _exactly_ match districts. These would usually be categorical covariates, with relatively few categories --otherwise the matching could fail, being too restrictive or even empty:
```{r}
exactMatchVars <-  c("distr.type")
```

Similarly, you can optionally specify covariates on which to match districts within a given numeric caliper, in terms of standard deviations. Such covariates are expected to be numeric variables. In this case, we are interested in caliper-matching on thre covariates: percentage of Black,  Hispanic, and  female students in the district.

Notice that the lower the caliper, the more restrictive the matching (which could result in ferwe proportion of successful matches per replacement group, or even empty ones):
```{r}
calipMatchVars <-  c("w.pct.black", "w.pct.hisp", "w.pct.female")
```

## Get unit matches

We'll now leverage sampling + MatchIt packages joint functionality, and match districts with their candidate replacements among the non-initially selected units using [Mahalanobis distance](https://en.wikipedia.org/wiki/Mahalanobis_distance). We can also do this using propensity scores, as specified on [MatchIt's documentation](https://cran.r-project.org/web/packages/MatchIt/vignettes/MatchIt.html#trying-a-different-matching-specification):

```{r}
matchOut <- selectMatch(df=dfCCD, # user dataset
                       unitID="LEAID", # column name of unit ID in user dataset
                       subunitID="NCESSCH", # column name of sub-unit ID in user dataset
                       unitVars=uSampVarsCCD, # name of unit level covariate columns
                       subunitSampVars=suSampVarsCCD, # name of sub-unit level covariate columns
                       exactMatchVars= exactMatchVars, # unit level categorical covariates on which to match exactly
                       calipMatchVars=calipMatchVars, # unit level numeric covariates on which to match within a radius
                       nUnitSamp = Nu, # original unit sample size
                       nRepUnits = K, # number of desired matches per initially selected unit
                       nsubUnits = Ns, # number of sub-units to sample from each candidate unit
                       calipValue = calip, # maximum distance on which to match specified unit level covariates (calipMatchVars)
                       seedN = seed, # random seed number
                       matchDistance = "mahalanobis", # metric used for matching units
                       sizeFlag = TRUE,
                       repFlag = FALSE, # pick matches without repetition
                       writeOut = FALSE, # write out a csv file for: 1) matched units and 2) selected schools
                       replacementUnitsFilename = "replacementsTable.csv", # filename for {districtA: [districtA replacement list]} table
                       subUnitTableFilename = "schoolsDirectory.csv" # filename for {districtA: [districtA schools]} table
)
```

At this point, the two main outputs of the selectMatch procedure have been produced, and are stored inside the 'matchOut' variable we've just defined. In our example, these are: 

1. A table with 10 matches (replacement candidates) for each of the 100 schools district we initially selected. The matches are ordered from the most to the least 'similar' to their original district (where 'similar' is close, in terms of covariate distance).

2. A table with 5 (or less, when there are less than 5 schools available for a given district) randomly (if applicable) selected schools for each of the 100 original __and__ each of the 100 x 10 candidate districts. Of course, each of these 5 schools  are sampled exclusively from those that belong to each school district:

```{r, results='asis'}
districtReplTable = matchOut[[1]]
knitr::kable(head(districtReplTable), format = "html")
```

```{r, results='asis'}
schoolDirectory = matchOut[[2]]
knitr::kable(head(dplyr::filter(schoolDirectory, !is.na(Sub_unit5_ID))), format = "html")

```

Each of these two tables can be automatically stored as .csv files in your local computer, by simply settin writeOut = TRUE in the main function call to selectMatch. In case you use this feature, you can given those two files a specific name, using the [replacementUnitsFilename][repFlag](https://sitepickr.github.io/sitepickR-website/reference/selectMatch.html) and [subUnitTableFilename][repFlag](https://sitepickr.github.io/sitepickR-website/reference/selectMatch.html) selectMatch arguments (or just keeping their default values).

## Assess balance and match quality

Now that we have our potential districts replacements, we'd like to know how 'similar' they really are to both the target population and the originally selected sample. Similarly, we'd like to know how well the schools that belong to each of these districts represent the schools of our target population, in terms of our covariates of interest. In the end, what we want is to be able to retain the original representativensess (imposed by our initial random sampling step) in our study design as much as possible, even when units "self-select".

sitepickR provides the user with several functions to carry out these balance diagnostics. By default --and following the standard literature-- balance diagnostics in sitepickR are expressed in terms of standardized mean difference (SMD) between two comparison groups of interest. In our case, these two comparison groups we'll be: 1) initially selected districts (or schools) against target population; 2) initially selected districts (or schools) against each of the 10 district replacement groups.

In addition, sitepickR has functions to find out how 'successful' the matching procedure was, to identify how often it was not possible to find all 10 matches for some units (perhaps because we are asking for 'too much' in terms of maximum distance, or exact matching constraints).


### 1. Original units vs. target population

First, we want to look at the overall balance between the initially selected districts (i.e. the group of districts that were selected in the initial cube sampling step of the selectMatch procedure) and __all__ the districts in the population:

```{r fig.width=6, fig.height=5}
unitLovePlot(matchOut,
   title="Standardized Mean Difference: \n Initially Selected Units vs. Population")
```

We can also take a look at a table with the actual SMD for each covariate of interest applying the  [summary()](https://sitepickr.github.io/sitepickR-website/reference/summary.html) function:

```{r, results='asis'}
unitBalanceTab = summary(matchOut, balMeasure=1)

knitr::kable(head(unitBalanceTab, 10), format = "html")
```


### 2. Original units vs. replacement candidates

To assess the quality of our resulting district matches, we look at the balance  (in terms of SMD) between the group of initially selected districts and each of its K replacement districts groups, where group 1 is composed of the first closest matches ordered in terms of distance, group 2 corresponds to the second-best matches, and so on:

```{r fig.width=9, fig.height=6}
matchBalance(matchOut, 
  title = "Standardized Mean Difference: Replacement Unit Groups (1...K) vs. Originally Selected Units")
```

```{r, results='asis'}
matchBalanceTab = summary(matchOut, balMeasure=2)
knitr::kable(head(matchBalanceTab, 20), format = "html")
```

### 3. Successfully computed unit matches

We also want to look at the success rate of the matching process between the original districts and the replacement candidate groups from the non-select pool: for each of their K replacements groups (ordered from most to least similar, in terms of all specified covariates), we look at the percentage of replacements. 

This percentage is expected to be inversely related to restrictions imposed by exact matching, caliper value, and inherent structure and size of the data, as well as K, the number of matches (i.e. replacement candidates) we want for each of the original districts:

```{r fig.width=7, fig.height=6}
matchCount(matchOut,
             title="Percentage of Successful Matches per Unit Group")
```

Similarly, we can, use [summary()](https://sitepickr.github.io/sitepickR-website/reference/summary.html)to obtain balance directly in a table:


```{r, results='asis'}
matchCountTab = summary(matchOut, balMeasure=3)

knitr::kable(matchCountTab, format = "html")
```

### 4. Sub-units from original vs. candidate units

Ultimately, the procedure wants to yield not just districts, but schools that are similar to the target population, in terms of all specified covariates of interest (both the district and school level ones). sitepickR's [subUnitBalance()](https://sitepickr.github.io/sitepickR-website/reference/subUnitBalance.html) function lets us assess the matching quality precisely on this terms:

```{r fig.width=9, fig.height=6}
subUnitBalance(matchOut,
                  title="Standardized Mean Difference: \n Sub-units from Original + Replacement Unit Groups vs. Population")
```

Similary, use [summary()](https://sitepickr.github.io/sitepickR-website/reference/summary.html) function to obtain balance directly in a table:


```{r, results='asis'}
subUnitBalanceTab = summary(matchOut, balMeasure=4)
knitr::kable(subUnitBalanceTab, format = "html")
```